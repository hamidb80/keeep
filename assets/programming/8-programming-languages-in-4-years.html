<note id="8-programming-languages-in-4-years" timestamp="1724472042">
  <summary>
  </summary>

  <article>
    <style>
      .pl-logo {
        max-height: 120px;
      }

      figure {
        text-align: center;
      }
    </style>


    <h1 digit>
      8
      زبان برنامه نویسی
      در
      4
      سال
    </h1>

    <h2 dir="auto">
      مقدمه
    </h2>

    <p dir="auto">
      سلام!
      دیگه دارم به پایان تحصیل در مفطع گارشناسی رشته مهندسی کامپیوتر نزدیک می‌شم.
    </p>
    <p dir="auto">
      خب شروع تحصیل من در دانشگاه تا تقریبا
      <span digit>2</span>
      سال بعد
      مصادف شده بود با
      دوران بیماری کرونا که باعث شد تا همه درس‌ها و حتی امتحانات هم مجازی برگزار بشه.

      این یعنی لازم نبود وقتمو توی رفت و آمد تلف کنم و کلی وقت آزاد داشتم.

      دغدغه اولم اکثر اوقات برنامه نویسی بوده؛
      که البته باعث شد خیلی جاها از درس بزنم که باعث بعضی مشکلات تحصیلی شد
      ...
    </p>

    <h2 dir="auto">
      قبل از دانشگاه
    </h2>

    <figure>
      <img class="pl-logo" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/python/python-original.svg" />
      <img class="pl-logo"
        src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/javascript/javascript-original.svg" />
    </figure>

    <p dir="auto">
      قبل از دانشگاه
      به لطف کلاس برنامه نویسی
      Java
      که یک ترم شرکت کرده بودم، مفاهیم ساده برنامه نویسی مثل تابع و متغیر
      و ...
      رو یادگرفتم.

      بعد از اون هم به صورت خودآموز
      <span footnote>
        هرجا دیدید کسی می‌گه خودآموز بزنید تو دهنش
        چون هرچیزی که ازش برای یادگیری استفاده کرده
        کسی زحمتش رو کشیده. به نظرم کلا اصطلاح اشتباهیه.
      </span>
      .
      یکمی
      <bdo dir="ltr">HTML و CSS</bdo>
      <small par><a href="https://www.aparat.com/v/ozZNu">سند</a></small>
      و بعد از مدتی
      Javascript
      و
      Python
      <small par><a href="https://vrgl.ir/NApN6">سند</a></small>
      رو یادگرفتم
      <small par><a href="https://www.aparat.com/v/y69ar64">سند</a></small>
      <span footnote>
        دوره های آقای امیرحسن عظیمی توی
        سایت
        Youtube
        که کانالی با اسم
        <a href="https://www.youtube.com/channel/UCW0ojdh94N5-bFiidIepdDg">
          ParsClick
        </a>
        یا
        پارس کلیک
        داره
        و به زبان فارسی بود، خیلی کمکم کرد.
        بسیار از ایشون تشکر می‌کنم
      </span>
      .
      از دنیای
      Javascript
      یکمی
      VueJs و React
      هم بلد بودم
      <small par><a href="https://github.com/hamidb80/subtitle-editor">سند</a></small>
      و
      کمی با
      ExpressJs
      کار کرده بودم
      <small par><a href="https://vrgl.ir/oObXy">سند</a></small>
      <span footnote>
        به لطف خدا عمرم رو خیلی با دیدن سریال های پوچ
        و بازی‌های گامپیوتری مسخره
        <mark>تلف</mark>
        نکردم
      </span>
      .
    </p>

    <p dir="auto">
      از زبان
      Javascript
      بخش
      Promise
      اش رو دوست دارم
      و از زبان
      Python
      بخش
      خوانایی اش رو.
      از زبان
      Javascript
      قسمت وجود آموزش‌های بسیار که نادقیق و کلی هستن بدم میاد
      و از زبان
      Python
      قسمت کتابخونه‌های متعدد پر از مشکل و
      framework
      هایی تفکر از پایه غلطی
      <span footnote>
        مثل Django
      </span>
      که باعث کلی مشکل می‌شه
      <span footnote>
        البته بعضی کتابخونه ها که شرکت های بزرگ پشتش هستن
        مثل
        Google
        در واقع از کیفیت خوبی برخورداره
      </span>

    </p>
    <p dir="auto">
      موقعی داشتم از
      Python
      ناامید می‌شدم که
      Zen of Python
      رو در حال نقض شدن توی تقریبا تمام پروژه ها و حتی خود زبان دیدم.

      زبان
      Python
      قرار بود ساده باشه ولی هرچی جلوتر می‌رفتم
      با مفاهیم نه چندان ساده بلکه گیج کننده
      <a trim href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments">
        مواجه می‌شدم
      </a>.
      کافیه فقط یکبار با
      async
      توی
      Javascript
      کار کنید تا
      به چیزی که توی
      Python
      پیاده سازی شده حتی نگاه هم نکنید.
      از اونور هم درسته، یعنی کافیه یکبار ورژن
      Python
      تون رو آپدیت کنید مثلا از
      3.7
      به
      3.8
      تا متوجه بشید برنامه نویس‌های
      Python
      چقدر بی‌مسئولیت هستن که نصف کتابخونه هایی که باهاش کار می‌کردید دیگه از کار میقته
      <span footnote>
        توی
        <a href="https://sokanacademy.com/blog/آموزش-کامل-semantic-versioning">
          این مطلب
        </a>
        در مورد قسمت
        minor
        بخونید
      </span>
      و در عین حال مشکلات جدید رو درست نمی‌کنن؛
      اون موقع قدر پایداری
      Javascript
      رو می‌دونید.
    </p>


    <h2 dir="auto">
      سال اول
    </h2>

    <p dir="auto">
      عرضم به خدمتتون که
      سال اول دانشگاه
      در درس های
      <i>
        مبانی زبان های نویسی
      </i>
      و
      <i>
        برنامه ننویسی پسرفته
      </i>
      <span footnote>
        اسم درست درس
        &quot;برنامه نویسی پیشرفته&quot;
        هست که بخاطر اینکه به هیچ عنوان جدی گرفته نشد و
        استاد بی‌سوادی هم داشت، به این صورت نوشتم
      </span>
      ،
      به ما
      <bdo dir="ltr">C و C++</bdo>
      درس دادن
    </p>


    <h3 dir="rtl">
      <bdo dir="ltr">C</bdo>
    </h3>

    <figure>
      <img class="pl-logo" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/c/c-original.svg" />
    </figure>

    <p dir="rtl">
      راستش چیز خاصی یادنگرفتم، صرفا فهمیدم که
      استفاده از
      Python
      در مقابل
      <bdo dir="ltr">C</bdo>
      آدم رو به
      <i>
        دوران انسان های اولیه
      </i>
      می‌بره:

    <ul dir="rtl">
      <li>
        <b>
          توی اون فضا حتی استفاده از کتابخونه ها هم داستان داشت
        </b>

        <ol dir="rtl">
          <li>
            اولا خیلی از کتابخونه ها و تابع هایی که تقریبا همیشه توی کد هام استفاده می‌کردم
            مثل
            split و replace
            توشون وجود نداشت، این یعنی
            یا باید دستی از اول دوباره می‌نوشتمشون یا باید
            از کد های بقیه که در قالب کتابخونه در اومده بود استفاده می‌کردم
          </li>
          <li>
            <i>Package Manager</i>
            یا نرم افزار مدیریت کتابخونه های دانلودی به صورت پیشفرش توش وجود نداشت
            و
            حتی با وجود دانلود کردن و اضافه کردن دستی کتابخونه،
            بعضی از کتابخونه ها باید قبل از استفاده به اصطلاح
            build
            می‌شدن و
            حتی بعدش هم موقع
            compile
            برنامه خود باید ی سری دستور اضافه وارد می‌کردیم
          </li>
        </ol>
      </li>

      <li>
        <p>
          اگر با
          Javascript
          کار کرده باشید احتمالا می‌دونید که حتی
          cross reference
          بین کد هاتون می‌تونید داشته باشید و مثل زبون های دیگه
          با مشکل
          وابستگی دایره‌ای
          <span footnote>
            Circular dependency
          </span>
          مواجه نمی‌شید
          <small>
            (برعکس پایتون).
          </small>

          اما توی
          C
          برای اینکه یک فایل بیشتر از 1 بار
          include
          نشه!
          مجبورید چند خط
          macro
          بنویسید،
          که در نوبه خودش عجیبه:
        </p>

        <pre><code block lang="c">
          #ifndef MY_MODULE_1
          #define MY_MODULE_1
          ...     // your code
          #endif
        </code></pre>

      </li>

      <li>
        compiler
        زبان
        C
        حتی قابلیت مقدار دهی متغیر های عمومی خارج از تابع هارو نداشت،
        چیزی که توی خیلی از زبان ها یک چیز رایج هست:
        <pre><code block lang="c">
            int a = 0;
            int b = a + 1; // &lt;-- Error: expression must have a constant value
            
            int main() { }
          </code></pre>
      </li>

      <li>
        و اما بد تر از همه،
        خیلی از اوقات برنامه ای که می‌توشتم،
        مشکلی داشت و ی دفعه برای
        چند لحظه
        freeze
        می‌شد و بعد هم ارور زیبای
        <code>core dumped</code>
        یا
        <code>segmentation fault</code>
        می‌داد
        <small>
          (
          البته بعضی از اوقات هم هیچی نمی‌نویسه و از
          exit code
          برنامه خودتون باید متوجه بشید
          )
        </small>
      </li>
    </ul>


    </p>

    <h3 dir="rtl">
      <bdo dir="ltr">C++</bdo>
    </h3>

    <figure>
      <img class="pl-logo"
        src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/cplusplus/cplusplus-original.svg" />
    </figure>

    <p dir="auto">
      ترم بعد بهمون
      <bdo dir="ltr">C++</bdo>
      یاد دادن. همونطور که احتمالا می‌دونید
      پسوند
      <code>++</code>
      در زبان
      C
      به معنی
      اضافه کردن هست،
      و خب همونطور که از اسمش معلومه، زبان
      <bdo dir="ltr">C++</bdo>
      باید یک نسخه بهتر و کامل تر
      C
      باشه.
    </p>

    <p dir="auto">

      قابلیت هایی بهش اضافه شده بودن، مثل:
    </p>

    <ul dir="rtl">
      <li>
        namespace
      </li>
      <li>
        function overload
      </li>
      <li>
        کتابخونه های پیشفرض غنی تر
      </li>
      <li>
        مدل مدیریت خطا
      </li>
      <li>
        برنامه نویسی شیء گرا
      </li>
    </ul>

    <p dir="auto">
      که مفید بودن ولی در عین حال
      مشکلات خودشون رو داشتن و
      هیچکدوم از مشکلاتی که باهاش داشتم غیر از مورد
      <code>expression must have a constant value</code>
      رفع نشده بودن:
    </p>

    <ul dir="rtl">
      <li>
        function overload
        اضافه شده بود ولی
        استفاده از
        template
        <a href="https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl">
          دردسر های مخصوص خودش
        </a>
        رو داشت
      </li>
      <li>
        کتابخونه های پیشفرض غنی تر شده بود ولی هنوز خیلی
        از توابع مثل
        split
        رو نداشت
        و عملا باز هم برای کارهای ساده شما به کتابخونه های دیگه احتیاج داشتید
      </li>
      <li>
        <b>
          مدل مدیریت خطا
        </b>

        با همون
        <bdo dir="ltr">try, catch, throw</bdo>
        اضافه شده بود ولی هنوز مشکل
        <code>core dumped</code>
        وجود داشت و هیچ اطلاعی از از اینکه مشکل توی کدوم قسمت برنامه افتاده به شما نمی‌داد
      </li>
      <li>
        <p>
          <b>
            برنامه نویسی شیء گرا
          </b>
          اضافه شده بود اما غیر اینکه
          syntax
          جالبی نداشت،
          در واقع خیلی فهم کد رو
          سخت می‌کرد، به حدی که استفاده از همون
          <code>struct</code>
          رو ترجیح می‌دادم.
          <a href="http://nomad.uk.net/articles/why-gos-design-is-a-disservice-to-intelligent-programmers.html">
            شاید دلیلی داشته
          </a>
          که سازنده های زبان برنامه نویسی
          Go
          شیء گرایی رو اضافه نکردن...
        </p>
        <p>
          برنامه نویسی شیء گرا
          کلی مشکلات داره که برای سامان دادنشون
          کلی
          design pattern
          <span footnote>
            الگوی طراحی
          </span>
          و قاعده واسش تعریف شده.
          قاعده‌هایی که توی درستی‌شون
          شک‌وشبه وجود داره
          <span footnote>
            <a href="https://solid-is-not-solid.com">
              SOLID is not solid
            </a>
          </span>
          و
          الگوهایی هم که توش استفاده می‌شه بیشتر گیج کننده است
          <span footnote>
            <a href="https://www.youtube.com/watch?v=IRTfhkiAqPw">
              Object-Oriented Programming is Embarrassing: 4 Short Examples 🎥
            </a>
          </span>
        </p>
      </li>
      <li>
        <p>
          و در نهایت با اضافه شدن
          کلی قابلیت جدید
          توی ورژن های جدید
          که خیلیاشون باهم همپوشانی دارن،
          کار رو برای برنامه نویساش سخت‌تر و سخت‌تر می‌کنه.
          <span footnote>
            <a href="https://www.youtube.com/watch?v=Z_ahq2h9Xxg">
              How C++ took a turn for the worse
            </a>
          </span>

          اگر شما برنامه نویس
          <bdo dir="ltr">C++</bdo>
          باشید شرط می‌بندم از خیلی از قابلیت هاش حتی اطلاع هم ندارید
          <span footnote>
            در مورد
            async
            که جدیدا معرفی شده چیزی می‌دونی؟
          </span>
          و
          <span footnote>
            <a href="https://www.youtube.com/watch?v=q1ZmFc-sqNc">
              the TRUTH about C++ (is it worth your time?)
            </a>
          </span>

        </p>

        <p>
          من نمی‌گم که
          <bdo dir="ltr">C++</bdo>
          نسبت به
          C
          هیچ پیشرفتی نداشته،

          <small par>
            البته آقای
            Linus Torvalds
            می‌گه
            <span footnote>
              <a href="https://medium.com/nerd-for-tech/linus-torvalds-c-is-really-a-terrible-language-2248b839bee3">
                C++ can’t solve the problem of the C language at all, it will only make things worse. This is a really
                bad language
              </a>
            </span>
          </small>

          حتما نسبت به نسخه‌های دیگه ای از
          C
          مثل
          Golden C
          برتری قابل توجهی داشته که محبوبیت پیدا کرده؛

          ولی به‌نظرم این همه مشکل
          <span footnote>
            <a href="https://www.youtube.com/watch?v=y37NzWaqpbI">
              Why C++ sometimes sucks (17 reasons)
            </a>
          </span>
          دیگه توی سال
          <span digit>2024</span>
          قابل توجیه و دفاع نیست.
        </p>

      </li>
    </ul>

    <h2 dir="auto">
      سال دوم
    </h2>

    <h3 dir="rtl">
      <bdo dir="ltr">Nim</bdo>
    </h3>

    <figure>
      <img class="pl-logo" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/nim/nim-original.svg" />
    </figure>

    <p dir="auto">
      خب ترم اول ی پروژه ماشین‌حساب اعداد بزرگ
      <span footnote>
        اعداد خارج از محدوده
        <code>int</code>
        و
        <code>float</code>
      </span>
      بود که من برنامه رو به این نحو نوشتم که میاد
      هر عدد رو توی یک آرایه
      5000
      تایی ذخیره می‌کرد و
      با اینکه اصلا به صورت بهینه نوشته نشده بود
      <span footnote>
        <a href="https://github.com/hamidb80/cli-calculator/">
          توی گیتهاب
        </a>
        نسخه
        بجای آرایه 5000 تایی از
        Vector
        استفاده کردم، ولی بهم گیر داده بودن که حتما آرایه باشه
      </span>
      موقع صدا زدن توابع،
      کل عدد رو که یک آرایه بود، کپی می‌کرد
      <span footnote>
        به این کار می‌گن
        pass by value
        در مقابل
        <a href="https://www.linkedin.com/pulse/pass-value-vs-reference-abdul-manan/">
          pass by reference
        </a>
      </span>
      و توی بعضی از توابع مثل ضرت با تقسیم این کار رو به
      دفعات متعدد انجام می‌داد؛
      اما با این حال به شدت سریع بود و
      توی چشم بهم زدنی جواب رو محاسبه می‌کرد.
      من که قبلا با
      Python
      کار کرده بودم،
      می‌دونستم
      <a href="https://images.app.goo.gl/71PaQuvGLhTJEBkN8">
        چنین سرعتی اونجا محاله
      </a>.
    </p>

    <p dir="auto">
      برای مدت‌ها به چیزی که توی اینترنت خونده بودم باور داشتم،
      که زبان های برنامه نویسی
      رو اگر روی یک محور بگذاریم،
      یک طرف می‌ش خوانایی و طرف مقابل می‌شه سرعت اجرا.
      این یعنی زبان‌هایی که سریع هستن، خوانایی کمی دارن
      و زبان‌هایی که خوانایی خوبی دارن، سرعتشون کمه.
    </p>

    <p dir="auto">
      با خودم گفتم
      <i>
        ای‌کاش زبانی وجود داشت که هردو تای این هارو باهم داشته باشه
      </i>.
      خب بخاطر همین توی
      Google
      به انگلیسی عبارت جایگزین های زبان
      <bdo dir="ltr">C</bdo>
      <span footnote>
        C programming language alternatives
      </span>
      رو جستجو کردم.
      چند تا زبان برنامه نویسی اومد:
    </p>

    <ul dir="rtl">
      <li>
        <b><bdo dir="ltr">C++</bdo></b>:
        اینو که قبلا تست کرده بودم و ازش بدم میومد
      </li>
      <li>
        <b>D</b>:
        این هم انگار چیز جدی‌ای نیست و
        برنامه نویساش بیشتر به صورت تفریحی روش کار می‌کنن
        و خیلی وقته که وضعیتش همینه و پیشرفتی نداشته
      </li>
      <li>
        <b>Rust</b>:

        تازگی ها خیلی بهش توجه می‌شه، تصمیم گرفتم تستش کنم ببینم چطوریه.
        <bdo dir="ltr">syntax</bdo>
        <span footnote>نوشتار</span>
        اش شبیه
        <bdo dir="ltr">C++</bdo>
        بود ولی یکم تمیز تر.

        یکم مستنداتش رو خوندم و سریع رفتم سراغ برنامه نوشتن.
        خواستم همون نسخه
        Hello World
        رو تغییر بدم به صورتی که
        فقط قسمت
        World
        رو به صورت ورودی به تابع بدم؛
        ولی خب به نظر می‌رسید که برای کار با نوع های داده‌ای
        غیر ساده
        <small par>
          غیر از
          <code>int</code>
          و
          <code>float</code>
          و
          <code>bool</code>
        </small>
        باید با مفهوم مالکیت
        <span footnote>ownership</span>
        و قرض و ...
        آشنا باشی که خب من راستش خیلی حوصله ام نرسید
        بیشتر از این ادامه بدم
        😂
        و رفتم سراغ بعدی
      </li>
      <li>
        <b>Nim</b>:

        وارد
        <a href="https://nim-lang.org">سایتش</a>
        شدم، بالای بالا نوشته بود:

        <mark>سریع، خوانا، ظریف</mark>
        <span footnote>Efficient, Expressive, Elegant</span>.
        پایین‌تر چند تا نمونه کد گذاشته بود که باهاش بیشتر آشنا بشم.
        syntax
        اش شبیه
        Python
        بود، شاید حتی زیبا تر.
        خب ظاهرش به دلم نشست، تصمیم گرفتم این یکی رو هم تست کنم
      </li>
    </ul>

    <p dir="auto">
      توی سایت خودش
      <span digit>3</span>
      صفحه آموزش
      <span footnote>Tutorial</span>
      داشت که همه‌اش رو خوندم.

      تصمیم گرفتم یکی از برنامه‌هایی که قبلا توی پایتون نوشته بودم رو
      دوباره اینجا بنویسم تا تفاوت رو احساس کنم.

      نوشتم و چند وقت بعد به
      <a trim href="https://github.com/hamidb80/sbttl">
        صورت کتابخونه منتشرش کردم
      </a>.
    </p>

    <p dir="auto">
      نکته جالب این بود که غیر از اینکه کد تمیز تر و خواناتر شد،
      به نسبت زیادی سریعتر هم شد.
      بله یکی از دلایلش اینه که زبان
      Nim
      به زبان
      C
      تبدیل و بعد
      compile
      می‌شه اما دلیل دیگه‌اش هم این بود که
      روش‌هایی که اینجا مثلا برای
      parse
      کردن یک عبارت استفاده می‌شه،
      صرفا شامل چند تا چک ساده است؛
      بر خلاف زبون‌هایی مثل
      Javascript و Python
      که کار‌های سنگینی مثل
      RegEx
      <span footnote>
        Regular Expressions
        یا
        عبارات با قاعده
      </span>
      مکررا استفاده می‌شه.
      این مورد توجیه می‌کنه چرا نتیجه گیری‌هایی که می‌گه

      <a href="https://www.youtube.com/watch?v=WLwTlC1R2sY">
        این زبان‌ها فقط
        <span digit>4</span>
        برابر کندتر هستن،
      </a>
      چقدر مسخره است
    </p>

    <p dir="auto">
      در ادامه خیلی از این زبان خوشم اومده بود،
      تقریبا همه کدهای شخصیم رو به این زبون می‌نوشتم.

      فضای خیلی جالبی داشت، چون به اندازه
      زبان‌های دیگه کتابخونه نداشت، مجبور بودم برم
      سر و ته‌اش رو دربیاریم و اون تیکه کد رو خودم بنویسم.
      مثلا کد تبدیل تاریخ میلادی
      <span footnote>
        خارجیا بهش می‌گن
        Gregorian
      </span>
      رو کسی قبلا توی این زبان ننوشته بود،
      منم از این فرصت استفاده کردم و از یک کد زبان
      Kotlin
      <a trim href="https://github.com/hamidb80/jalali_nim">
        به این زبان ترجمه کردم
      </a>،
      یا
      <a trim href="https://github.com/hamidb80/mycouch">
        رابط پایگاه داده
        CouchDB
      </a>.
      بعضی موقع ها هم کتابخونه های موجود خوب نبودن و
      بلد بودم، خودم بهترش رو نوشتم؛
      مثل
      <a href="https://github.com/hamidb80/emath">
        کتابخونه خوندن عبارت ریاضی
      </a>
      یا
      <a href="https://github.com/hamidb80/iterrr">
        کتابخونه پیمایش
        شبیه زبان‌های
        تابع‌گرا
        <span footnote>
          functional
        </span>
      </a>
      که ماشاالله تونست 70 تا ستاره ⭐ بگیره.

      بعضی موقع ها هم برای ی چیزی چند تا تابع می‌نوشتم
      و برای اینکه بقیه هم ازش استفاده کنن، عمومی اش می‌کردم؛
      <a trim href="https://github.com/hamidb80/packedArgs">
        مثل این
      </a>.

      سادگی
      <span footnote>
        توجه داشته باشید که ساده با آسون فرق می‌کنه.
        برای درک بهتر عنوان این سخنرانی رو توی اینترنت جستحو کنید:

        simple made easy
      </span>
      و قابل فهم بودن این زبان،
      به من توانایی این رو داد که
      من برای اولین بار توی عمرم
      تونستم مشکلی رو حل کنم و
      pull request
      بزنم.
    </p>

    <h4 dir="auto">
      چیزهایی که یادگرفتم
    </h4>

    <ul dir="auto">
      <li>
        <b>
          برنامه نویسی ساخت یافته
        </b>
        <span footnote>
          Structural Programming
        </span>
        :
        این روش برنامه نویسی که سازنده
        Nim
        روش تاکید داره، اینطوریه که می‌گه تا جایی که
        ممکنه برنامه نباید
        exit point
        هایی مثل
        return
        و
        break
        در بیش از یک محل داشته باشه.
        یا می‌گه که هر
        if
        باید یک
        else
        وجود داشته باشه.
        اینطوری کدت استدلال پذیر می‌شه یعنی اگر به مشکلی برخورد کردی،
        حدس محل وقوع مشکل راحت تره.
        من این مورد رو یادگرفتم و حتی توی زبان‌های دیگه ای هم که
        برنامه نویسی می‌کنم، این مورد رو رعایت می‌کنم و واقعا جواب می‌ده
      </li>

      <li>
        <p dir="auto">
          <b>
            مدل کردن مسئله:
          </b>
          توی
          Nim
          مفاهیمی مثل
          <code>class</code>
          وجود ندارن و بجاش
          <code>object</code>
          هست که خیلی شبیه به
          <code>struct</code>
          در زبان
          C
          و فقط
          field
          های داده‌ای داره.

          شاید فکر کنید که
          Nim
          اینطوری خیلی سخت می‌شه و
          خوبی های برنامه نویسی شیء گرا رو نداره؛
          اما سخت در اشتباهید چون اولا
          شیء گرایی رو پشتیبانی می‌کنه ولی پیشنهاد کرده که ازش استفاده نکنید،
          دوما قابلیت‌های قوی‌تری داره که شما رو تقریبا از اون فضا بی‌نیاز می‌کنه.
        </p>

        <pre><code block lang="nim">
            var 
              s = &quot;Salam&quot;
              i = &quot; Donya&quot;

            # ---- 1 param ----

            echo(s)
            echo s
            s.echo()
            s.echo
            echo: s
            echo(): s
            echo: 
              s

            # ---- 2 params ----

            add(s, i)
            add s, i
            s.add(i)
            s.add i
            add s, i
            add s: i
            add(s): i
            s.add(): i
            
            add:
              s
            do:
              i
          </code></pre>

        <p dir="auto">
          قطعه کد بالا حالاتی رو توی
          <code>---- 1 param ----</code>
          کد های معادل برای صدا زدن تابع با یک ورودی
          و قسمت
          <code>---- 2 params ----</code>
          کد های معادل صدا زدن یک تابع با
          <span digit>2</span>
          ورودی رو نشون می‌ده.

          این یعنی شما می‌تونید زمان بیشتری رو
          برای فکر کردن صرف کنید تا اینکه
          به این فکر کنید که
          آیا فلان چیز
          Method
          بود یا
          تابع بود یا نه اصلا
          attribute
          بود؟
        </p>

        <p>
          زبان
          Nim
          قابلیت هایی خیلی خیلی قوی‌تز از
          decorator
          توی
          Python
          یا بقیه زبان ها داره که به شما عملا اجازه با قطعه کد زیرش هرکاری بکنید.

          این قابلیت ها به حدی خوب هستن که
          واقعا بقیه چیزها در مقابلش بچه بازی محسوب می‌شن.
          فعلا زبان رو پیدا نکردم که در
          فقط در بخش خوانایی کد بتونه به گرد پاش برسه؛
          زبان
          Python
          یا
          Ruby
          نزدیک هستن ولی
          Nim
          واقعا ی چیز دیگست ...
        </p>

        <p>
          خب داشت یادم می‌رفت موضوع رو،
          سادگی و خوانایی در عین پشتیبانی
          نهی شده از شیء گرایی،
          به شما این اجازه رو می‌ده که بجای تمرکز روی مباحث
          بی‌اهمیت، روی مسئله‌تون وقت بگذارید.
          در طول مدت برنامه نویسی به این فکر کنید که سختار
          <code>object</code>
          ها رو چطور بچینم که به بهترین شکل بتونه مسئله رو حل کنم باهاشون؟
          و چه تابع های بنویسم که بتونه با این
          object
          ها کار بکنه؟
        </p>
      </li>

      <li>
        <p dir="auto">

          <b>

            کار با ساختمان داده‌های درختی
          </b>:

          خب قبل از اینکه با
          macro
          ها آشنا بشم،
          صرفا فکر می‌کردم ساختمان داده درختی
          صرفا ی چیزیه که جاش توی دانشگاه هست و البته شاید
          بعضی موقع ها هم بدرد بخوره مثل
          Binary Search Tree
          که البته اونم کدش توی اینترنت هست.
        </p>

        <p dir="rtl">
          macro
          در زبان Nim
          تابعی هست که
          <i>
            ورودی‌شون کد
          </i>
          و
          <i>
            خروجی‌شون هم کد
          </i>
          هست.

          البته کدی که به
          macro
          تحویل داده می‌شه
          نه یک قطعه
          <code>string</code>
          بلکه یک

          <a trim href="https://sokanacademy.com/glossary/abstract-syntax-tree">
            درخت مفهومی نوشتار
          </a>
          <span footnote>
            Abstact Syntax Tree یا AST
          </span>
          هست که خب
          نوشتن تعدادی
          macro
          باعث شد که توی کار با ساختمان داده درخت
          مهارت خوبی پیدا کنم
          <span footnote>
            اگر کار با درخت توی برنامه نویسی بلد نیستی،
            به نظرم اصلا نمی‌دونی برنامه نویسی چیه
          </span>
        </p>
      </li>

      <li>
        <p dir="auto">

          <b>
            کار کردن با
            Thread
            ها
          </b>:

          خب کار کردن با
          Thread
          توی زبون
          Python
          مثل یک جک بی‌مزه می‌مونه چون
          یکی از مهم ترین اهداف این کار
          افزایش کارایی هست،
          در صورتی که
          Thread
          ها در
          Python
          بخاطر وجود
          <a href="https://roocket.ir/articles/python-gil">
            GIL
          </a>
          نوبتی اجرا می‌شن؛
          البته کتابخونه هایی مثل
          subprocess
          این مشکل رو ندارن ولی کار کردن باهاشون خیلی فرق داره و کلا ی چیز دیگه است.
          اینجاست که گفتم خود زبان
          Python
          تفکر
          Zen of Python
          رو نقض می‌کنه چون اصلا اصلا اصلا اینا ساده نیستن
          و حتی سخت تر از زبونای برنامه نویسی دیگه هستن،
          همه‌اش بخاطر تفکر پایه‌ای غلط.
        </p>

        <p dir="auto">
          توی زبان
          Javascript
          هم نسبتا بد نیست و خودش همه چیز رو مدیریت می‌کنه.
          از
          Python
          توی این زمینه که خیلی بهتره ولی خب توی
          Nim
          دست شما باز تره برای مدیریت‌شون، که هرکدوم خوبی و بدی خودشون رو دارن
        </p>
      </li>

    </ul>

    <h4 dir="auto">
      نکات منفی
    </h4>

    <p dir="auto">
      خب هیچ چیز کاملا خوب نیست،
      بلکه نسبتی از خوبی و بدی هست.
      مثل زبان
      Nim
      یا هر چیز دیگه ای توی دنیا
    </p>

    <ul dir="rtl">
      <li>
        <p dir="auto">
          <b>
            جامعه کوچک
          </b>:
          خب تعداد برنامه نویس‌هایی که این زبون رو می‌شناسن
          هم حتی خیلی نیستن، چه برسه به کسایی که ازش استفاده می‌کنن!

          این مورد باعث می‌شه که احتمالا کتابخونه هایی که بهش نیاز دارید و
          توی زبون‌های دیگه ازش استفاده می‌کنید، اینجا موجود نباشه.
        </p>
        <p dir="auto">
          البته می‌تونید
          کتابخونه های زبان های
          <bdo dir="ltr">C و C++</bdo>
          رو توی
          Nim
          استفاده کنید، ولی خب خیلی هم دلچسب نیست
        </p>
      </li>

      <li>
        <p dir="auto">

          <b>
            مشکلات احتمالی
          </b>:
          خب اون موقعی که من استفاده از
          Nim
          رو شروع کردم،
          نسبتا جوون بود و ممکن بود به چیزی برخورد کنید
          که ندونید مشکل از کد خودتون هست یا خود
          Nim 🤣.

          <a trim href="https://github.com/nim-lang/Nim/issues?q=is%3Aissue+author%3Ahamidb80">
            فقط ببینید که من تنهایی چند تا
            issue
            توی
            github
            شون باز کردم.
          </a>
          <small par>
            البته همه شون
            Bug
            <span footnote>
              مشکل کامپیوتری
            </span>
            نیستن
          </small>

          اما از ورژن
          <span digit>2</span>
          به بعد خیلی پایدارتر شده
        </p>
      </li>
    </ul>


    <h3 dir="rtl">
      <bdo dir="ltr">Elixir</bdo>
    </h3>

    <figure>
      <img class="pl-logo" src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/elixir/elixir-original.svg" />
    </figure>

    <p dir="auto">
      این زبان ی جورایی بچه‌ی زبان
      Erlang
      حساب می‌شه و برای شرکت مخاربراتی
      Ericsson
      ساخته شده بود، با هدف اینکه
      بتونه تعداد زیادی کاربر رو بدون مشکل و بطور همزمان مدیریت کنه.

      از جمله قابلیت های ویژه‌ای که برای این کار داره،
      می‌شه به
      supervision tree
      برای
      مدیریت و تصمیم گیری برای
      Process
      های مختلف
      و
      مدل
      مدیریت
      Thread
      به روش
      M:N
      با ایجاد
      LWP
      <span footnote>
        توی کتاب‌های دانشگاهی بهش می‌گن
        Light Weight Process
        ،
        توی اینترنت با اسم
        Green Thread
        می‌شناسنش
      </span>
      و
      عدم قابلیت تغییر داده
      <small par>immutability</small>
      اشاره کرد.
      این زبان توی مدیریت
      Process و Thread
      <span footnote>
        <a href="https://dmitrykakurin.medium.com/concurrency-in-go-pony-erlang-elixir-and-rust-35a4eb4bb48f">
          Concurrency in Go, Pony, Erlang/Elixir, and Rust
        </a>
      </span>
      ها از همه ی سر و گردن بالاتره
      که شاید یکی از دلایلش استفاده از مدل ارتباطی
      Actor
      <span footnote>
        <a href="https://doc.postsharp.net/il/threading/actor">
          Actor Threading Model
        </a>
      </span>
      هست.
    </p>

    <p dir="auto">
      این یکی رو
      بیشتر بخاطر اینکه
      functional
      بود خواستم یادبگیرم.
      به طور خلاصه زبان‌های
      functional
      چیزی به نام متغیر وجود نداره
      <span footnote>
        البته متغیر داریم ولی تحت شرایط خاصی
        و اصلا اصلا رایج نیست
      </span>.
      شاید بگید که خب ممکنه یک آرایه
      n
      تایی داشته باشیم، که در این صورت با هربار تغییر یکی از
      خونه های آرایه، کل‌اش رو
      copy
      کنیم؛
      خب این قضیه ممکنه رخ نده به دلیل یک سری بهینه سازی ها،
      که اگر که تشخیص بده نیازی بهش نیست،
      اما خیلی اوقات هم رخ می‌ده و این تصمیمی هست که گرفتن؛
      به جهت اینکه یکی از مشکلات اصلی توی برنامه هایی که موازی اجرا می‌شن،
      مشکل
      <a href="https://www.aparat.com/v/O42LY">
        <bdo dir="ltr">
          Race Condition 🏁
        </bdo>
      </a>
      <span footnote>
        حالت مسابقه
      </span>
      هست
      که بخاطر وجود حافظه مشترک اتفاق میفته.
    </p>
    <p dir="auto">
      اگر هیچ حافظه مشترکی بین
      برنامه‌هات نباشن، این یعنی که
      Race Condition
      ای رخ نمی‌ده.
      دیدید؟
      <i>
        کلا صورت مسئله پاک شد
      </i>
      😁
    </p>

    <h4 dir="auto">
      چیز هایی که یادگرفتم
    </h4>

    <ul dir="auto">
      <li>
        <p dir="auto">
          <b>
            تبدیل حلقه به
            تابع بازگشتی
          </b>:

          یکی از عجایب زبون‌های
          functional
          <small par>البته نه همه‌شون</small>
          اینه که چیزی به نام حلقه ندارن و
          شما مجبوری همه حلقه هات رو به صورت تابع بازگشتی بنویسی.
        </p>
        <p dir="auto">
          خب شاید واسه تون سوال بشه که
          <i>
            آیا این مورد باعث ارور
            Stack Overflow
            <span footnote>
              وقتی رخ می‌ده که تعداد
              تابع‌های تو در توی صدا زده شده بیشتر از حد مجاز باشه
            </span>
            نمی‌شه؟
          </i>
          جوابش هم اره و هم نه هست؛
          موقعی این اتفاق نمی‌فته که عبارت پایانی تابع‌تون
          <b>
            تابعی
            باشه که
            <mark trim>
              به صورت تنها
            </mark>
            صدا زده شده باشه.
          </b>
          در غیر این صورت در تکرار های بالا باعث اروری که اشاره شد، می‌شه.

          برای مثال دو تا تابع زیر برای محاسبه فاکتوریل رو در نظر بگیرید:
        </p>

        <pre><code block lang="elixir">
            def f_recur(1), do: 1
            def f_recur(n) do
              f_recur(n - 1) * n
            end

            def f_tco(1, result \\ 1), do: result
            def f_tco(n, result \\ 1)  do 
              f_tco(n - 1, n * result)
            end
          </code></pre>

        <p dir="auto">
          تابع
          <code>f_recur</code>
          یک تابع بازگشتی معمولی هست، چون برای محاسبه
          فاکتوریل
          n،
          اول باید فاکتوریل
          n-1
          رو کامل حساب کنه
          <small par>
            که خودشم باز نیاز به محاسبه
            فاکتوریل
            n-2
            داره
            و ...
          </small>
          ،
          اما برای تابع
          <code>f_tco</code>
          نه. اجازه بدید نشون بدم چطوری اجرا می‌شن:
        </p>

        <pre><code block lang="python">
            f_recur(4) 
            (f_recur(3) * 4) 
            ((f_recur(2) * 3) * 4) 
            (((f_recur(1) * 2) * 3) * 4) 
            (((1 * 2) * 3) * 4) 
            ((2 * 3) * 4) 
            (6 * 4) 
            24

            f_tco(4) 
            f_tco(3, 4)
            f_tco(2, 12) 
            f_tco(1, 24) 
            24
          </code></pre>

        <p>
          خب همینطور که دیدید،
          تابع
          <code>f_tco</code>
          یک روند اجرای خطی داره و
          compiler
          کد رو بهینه می‌کنه
          ولی در تابع
          <code>f_recur</code>
          این قضیه دقیقا برعکسه و برای اجرا کامپیوتر باید تا ته بره و بعد برگرده.

          به این بهینه سازی می‌گن
          Tail Call Optimization
          <span footnote>
            بهینه سازی صدا زدن تابع در انتها
          </span>
          یا
          TCO
        </p>
      </li>

      <li>
        <b>
          برنامه نویسی ساخت یافته
        </b>:

        راستش زبان‌های
        functional
        خیلیاشون چیزی به نام
        <code>return</code>
        ندارن و نتیجه تابع شما می‌شه خروجی آخرین دستوری که اجرا شده.

        این موضوع به شما رو
        <b>مجبور</b>
        می‌کنه
        که به‌طور خاصی برنامه بنویسید
      </li>

      <li>
        <b>
          مدل های مدیریت
          Thread
        </b>:

        برای درک فلسفه ساخت
        زبان پدر یا همون
        Erlang
        مجبور شدم برم درباره اش مطالعه کنم
      </li>

      <li>
        <b>
          استفاده از
          higher order functions
        </b>:

        غیر از تبدیل حلقه به تابع بازگشتی،
        اگر که الگوی خاصی داشته باشه،
        می‌تونید از توابعی مثل
        <code>map</code>
        و
        <code>reduce</code>
        و ...
        استفاده کنید
      </li>

    </ul>

    <h4 dir="auto">
      معایب
    </h4>

    <p dir="auto">
      راستش زبان
      Elixir
      همونطور که اول گفتم برای کارای بزرگ ساخته شده،
      و بخاطر این قضیه یکسری پیچیدگی‌ها که به نظرم لازمه توش وجود داره؛
      ولی برای منی که نه دغدغه اش رو دارم و نه می‌تونم از پتانسیل هاش استفاده کنم،
      ی جورایی بی‌معنیه.
      در هر صورت خودم را آدم لایقی برای نقد نمی‌دونم،
      اما به چندتا که واقعا حس کردم اشاره می‌کنم:
    </p>

    <ul dir="auto">
      <li>
        نمی‌دونم چرا با اینکه این زبان
        functional
        هست ولی
        کتابخونه های معروفش مثل
        Ecto
        به حالت
        شیء گرایی نوشته شده
        و ساده نیست واقعا
      </li>
      <li>
        syntax
        اش
        ترکیبی از
        Erlang
        و
        Ruby
        هست به علاوه سلیقه خودشون.
        یکمی عجیب و غریبه
        و بعضی موقع‌ها
        تکرار توش زیاده و این موضوع واقعا حس می‌شه
      </li>
    </ul>

    <h2 dir="auto">
      سال سوم
    </h2>

    <p dir="auto">
      این سال زبان
      دو تا زبان از خانواده
      LISP
      یادگرفتم.
      کلمه
      LISP
      از دو تا کلمه
      <u>Lis</u>t <u>P</u>rocessing
      تشکیل شده و خب همونطوری که از اسمش پیداست،
      نقطه قوتش توی کار با
      Linked List
      هست.
      خیلی جالبه که حتی
      syntax
      اش هم به صورت
      list
      هست که بهش می‌گن
      s-expression
    </p>

    <p dir="auto">
      این
      s-expression
      پر از پرانتزه و برای همه کاری هم لازمه.
      مثلا توی زبان
      C
      هم از
      <code>[]</code>
      و
      <code>{}</code>
      و
      <code>()</code>
      استفاده می‌کنن ولی توی
      LISP
      همه اش تقریبا
      <code>()</code>
      هست.

      برای مثال این عبارت توی
      رو در نظر بگیرید:
    </p>

    <pre><code block lang="python">
      2 * 3 + 4
    </code></pre>

    <p dir="auto">
      معادل
      LISP
      اش می‌شه
    </p>

    <pre><code block lang="lisp">
      (+ (* 2 3) 4)
    </code></pre>

    <p dir="auto">
      همونطور که می‌بینید،
      تابع‌ها
      درون پرانتز نوشته می‌شه
      و کلا یک روش برای صدا زدن تابع‌ها بیشتر وجود نداره.

      یعنی مثل بعضی از زبان ها
      نمی‌تونید تابع رو بین ورودی ها
      <code>a + b</code>
      یا بعد از ورودی
      <code>a++</code>
      بنویسید؛
      فقط حالا پیش از ورودی ها مجازه، اونم به این صورت:
      <bdo dir="ltr"><code>(fn a b c d ...)</code></bdo>
    </p>

    <p dir="auto">
      حالا ی مثال دیگه:
    </p>

    <pre><code block lang="python">
      sin(11 / 9 * pi) + 3 * cos(0) + 12
    </code></pre>

    <pre><code block lang="lisp">
      (+ (sin (* (/ 11  9) π)) (* 3 (cos 0)) 12)
    </code></pre>

    <p dir="auto">
      کد زیر هم تابع محاسبه
      ریشه‌های معادله درجه
      <span digit>2</span>
      هست:
    </p>

    <pre><code block lang="lisp">
      (defun quadratic-solver (a b c)
        &quot;Solve the quadratic equation ax² + bx + c = 0.&quot;
        (let ((Δ² (- (* b b) (* 4 a c))))
        (cond
          ;; Two real and distinct roots
          ((&gt; Δ² 0)
            (list (/ (+ - b (sqrt Δ²)) (* 2 a))
                  (/ (- - b (sqrt Δ²)) (* 2 a))))
          ;; One real root
          ((= Δ² 0)
            (list (/ - b (* 2 a))))
          ;; No real roots
          (t (list &quot;No real roots.&quot;)))))

      ;; Example usage:
      (quadratic-solver 1 -3 2)
    </code></pre>

    <h3 dir="rtl">
      Racket
    </h3>

    <figure>
      <img class="pl-logo" src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Racket-logo.svg" alt="">
    </figure>

    <p dir="auto">
      راستش توی اینترنت خونده بودم
      که
      چند تا ایده‌هایی که تقریبا همه زبان‌ها دارن،
      برای اولین بار توی
      LISP
      پیاده سازی شده.
      مثل
      closure function
      <span footnote>
        تابعی که به متغیرهای جایی که ساخته شده دسترسی داره
      </span>
      و
      garbage collector
      و
      meta programming
      با
      macro
      ها
      ؛
      بخاطر همین گفتم ی تستش بکنم.
    </p>
    <p dir="auto">
      اول رفتم سراغ
      Clojure
      اما نصبش ارور داد
      و دنبال یک زبان خانواده
      LISP
      گشتم که راحت بتونم نصبش کنم؛
      تا اینکه
      Racket
      رو پیدا کردم
    </p>

    <h4 dir="auto">
      نقاط ضعف
    </h4>
    <p dir="auto">
      راستش
      یکمی باهاش کار کردم ولی خوشم نیومد ازش:
    </p>

    <ul dir="rtl">
      <li>
        تابع هاش
        به صورت
        <b>
          یکنواخت
        </b>
        روی هردو
        list
        و
        Vector
        و
        string
        کار نمی‌کردن
        و این موضوع واقعا آدم رو آزار می‌داد
      </li>
      <li>
        با اینکه سن زیادی داره ولی
        هنوز هم بالغ نشده،
        یعنی کتابخونه های زیادی نداره و همونایی هم که داره کامل نیستن
      </li>
      <li>
        زبون خیلی پیچیده طراحی شده و حس می‌شه که
        قابلیت هاش باهم جور در نمیان
      </li>
      <li>
        با اینکه
        ادعا می‌کنن که
        Racket
        <b>
          یک زبان
          functional
        </b>
        هست ولی نمی‌دونم این همه
        تابع برای تغییر مقدار متغیرها
        <span footnote>
          به اصطلاح
          mutate
          کردن
        </span>
        پس چیه؟
        چرا
        class
        داره؟
        مگه شیء گراست؟!؟
      </li>
      <li>
        <b>
          جامعه
        </b>
        کوچیکی داره ولی
        چون قدیمیه انتظار دیگه ای ازش میره.
        کسایی که توش فعالیت می‌کنن هم به نظر می‌رسه
        که برنامه نویس‌های بروز و باسوادی نیستن
      </li>
    </ul>


    <h3 dir="rtl">
      Common Lisp
    </h3>

    <figure>
      <img class="pl-logo" src="https://upload.wikimedia.org/wikipedia/commons/4/48/Lisp_logo.svg" alt="">
    </figure>

    <p dir="auto">
      کتاب
      Land of lisp
      رو از اینترنت دانلود کردم.
      اگر اشتباه نکنم واسه سال
      <span digit>2007</span>
      بود.
      کتاب زبان
      LISP
      رو
      <i>
        تکنولوژی آدم فضایی‌ها
      </i>
      <span footnote>
        Alien Technology
      </span>
      معرفی می‌کرد 😮.

      انصافا کتاب خوبی بود،
      همه چیز رو با
      ecosystem
      زبان
      LISP
      یاد می‌داد.
      مثلا برای نرم‌افزار کدنویسی
      گفته بود که یکی از ورژن‌های آماده
      Emacs
      که اسمش
      Portacle
      بود رو نصب کنید
      <small par>
        Emacs
        خودشم با
        یکی از زبان‌های خانواده
        LISP
        نوشته شده
      </small>
      .
      روی
      Portacle
      به صورت پیشرفض
      ی سری افزونه ها مثل
      Expand Region
      <small footnote>
        واقعا یکی از بهترین افزونه‌هایی هست که
        توی عمرم دیدم، روی
        VS Code
        هم نصبش کردم
      </small>
      بود که کار با این پرانتز های تو در تو رو خیلی ساده می‌کرد.
      یا مثل کار با
      Sly
      رو یاد داد که یکی از
      REPL
      <span footnote>
        قابلیت
        Read Eval Print Loop
        همون جایی که کد رو وارد می‌کنن و سریع جواب رو می‌گیرن.
        زبون‌هایی
        که
        interpreter
        دارن
        تقریبا همه شون
        REPL
        هم دارن مثل
        Python
        و
        Javascript
      </span>
      های خفن
      زبان
      Common LISP
      هست.
    </p>

    <h4 dir="auto">
      مزایا
    </h4>

    <ul dir="rtl">
      <li>
        <p dir="rtl">
          <b>
            <a href="https://gigamonkeys.com/book/loop-for-black-belts">
              Loop macro
            </a>
          </b>:

          باحال‌ترین
          چیزی که توی
          LISP
          دیدم
          macro
          ای به‌نام
          Loop
          بود.

          نکته جالب‌اش اینه که انگار داری
          انگلیسی تایپ می‌کنی و به برنامه نویسی خیلی شبیه نیست.

          مثلا حلقه زیر توی لیستی به نام
          <code>*list_of_number*</code>
          پیمایش می‌کنه،
          تعداد زوج هارو می‌ریزه توی
          <code>even</code>
          تعداد فرد هارو می‌ریزه توی
          <code>odd</code>،
          جمعشون رو می‌ریزه توی
          <code>total</code>
          بیشترین رو نوی
          <code>max</code>
          و کمترین رو توی
          <code>min</code>،
          در نهایت به صورت یک لیست خروجی می‌ده همه شون رو:
        </p>
        <pre><code block lang="lisp">
            (loop for i in *list_of_number*
              counting (evenp i) into evens
              counting (oddp i) into odds
              summing i into total
              maximizing i into max
              minimizing i into min
              finally (return (list min max total evens odds)))
          </code></pre>
      </li>
      <li>
        ابزار هایی که برای کار با
        linked list
        داشت خیلی خوب بود،
        مثل تابع‌های
        <code>car</code>
        و
        <code>cdr</code>
        و
        <code>cadr</code>
        و
        <code>cddr</code>
        و...
        البته انتظار هم می‌ره که اینطوری باشه چون اسم زبون هم همینو می‌گه
      </li>
    </ul>

    <h4 dir="auto">
      معایب
    </h4>

    <ul dir="rtl">
      <li>
        راستش درسته که ایده‌هایی که مطرح کرده
        اون زمان خیلی محشر بوده،
        ولی همین بهترین ایده‌هاش رو خیلی از زبان‌های برنامه نویسی دیگه هم دارن.
        مثل همین بهترین قابلیت
        LISP
        که
        macro
        هاش بودن.
        همین
        macro
        ها مشابه یا حتی بهترش رو توی زبان
        Elixir
        و
        Nim
        دیدم.
        یعنی نقاط قوت
        LISP
        واقعا دیگه
        <b>نقاط قوت</b>
        حساب نمی‌شن
      </li>

      <li>
        خیلی از کارهای توی زبان‌های دیگه مثل
        Javascript
        و
        Python
        مثل کار با پایگاه داده یا
        ساخت یک
        web server
        <mark>
          خیلی ساده تر
        </mark>
        هست.
        عملا با وجود رقبا،
        <i>
          سادگی دیگه نقطه قوت
          زبان
          LISP
          محسوب نمی‌شه
        </i>
      </li>

      <li>
        زبان
        Common LISP
        برای هدفی که براش
        خلق شده
        <small par>
          کار با
          Linked list
        </small>
        عالیه ولی
        مشکل از اونجایی شروع می‌شه که
        خواستن
        class
        و
        شیء گرایی
        رو با
        CLOS
        <span footnote>
          Common Lisp Object System
        </span>
        به زور به زبون اضافه کنن که فقط زبون رو پیچیده کرد.
      </li>

      <li>
        زبان رها شده و می‌شه گفت تقریبا مرده
        ☠️
        <small par>
          فقط زبان
          Common Lisp
          رو گفتم نه کل خانواده
          Lisp
        </small>.
        تقریبا همه آموزش ها واسه دوران اوج
        LISP
        هستن و چیز جدیدی در دسترس نیست
      </li>
    </ul>

    <h2 dir="auto">
      سال چهارم
    </h2>

    <p dir="auto">
      زبان‌های برنامه نویسی
      <b>
        آرایه‌ای
      </b>
      همونطور که از اسم‌شون پیداست،
      از پایه برای کار با آرایه ساخته شدن.

      این یعنی انتظار می‌ره چنین عملیات‌هایی
      توی این زبان‌ها سریع‌تر و راحت‌تر انجام بشه و واقعا هم همینطوره
    </p>

    <p dir="auto">
      احساس می‌شه که توی این زبان ها
      نوع نگاه به مسئله به صورت کلی‌نگری هست که با توجه به شرایط، این
      موضوع می‌تونه خوب یا بد باشه
    </p>

    <p dir="auto">
      نکته جالب دیگه در مورد این زبان‌ها اینه که
      تقریبا همه تابع‌ها و مفاهیم اصلی با یک کاراکتر نمایش داده می‌شه.

      مثلا برای جذر گرفتن، بجای استفاده از تابع هایی مثل
      <code>sqrt</code>
      توی زبان‌های دیگه مثل
      Python،
      <a href="https://www.compart.com/en/unicode/category/Sm">
        از خود کاراکترش
      </a>
      استفاده می‌کنن
      <kbd>√</kbd>
    </p>

    <h3 dir="rtl">
      Uiua
    </h3>

    <figure>
      <img class="pl-logo" src="https://upload.wikimedia.org/wikipedia/commons/9/97/Uiua-logo.png" alt="">
    </figure>

    <p dir="auto">
      نحوه آشنایی من با این زبون و ایجاد اشتیاق
      🤩
      برای یادگیریش،
      بعد از خوندن
      <a href="https://citizen428.net/blog/exploring-uiua/">
        Exploring Uiua
      </a>
      به‌وجود اومد
    </p>

    <p dir="auto">
      این زبان به نوع خودش خیلی چیزای
      <i>
        غیر معمول و عجیب
      </i>
      🔮
      زیاد داشت:
    </p>

    <ul dir="rtl">
      <li>
        <p>
          <b>
            tacit programming
          </b>:

          ی نوع روش برنامه نویسیه که متغیر توش نداری و مستقیم
          با
          <b>
            stack
          </b>
          سر و کله می‌زنی.
        </p>
        <p dir="auto">
          نحوه اجرای کد توی این زبان
          از بالا به پایین
          ⬇
          و
          از راست به چپ
          ⬅
          هست.
          برای مثل اگر بخواید
          <span digit>2</span>
          تا عدد رو با هم جمع کنید،
          اول باید بندازیدش توی
          stack
          و بعد تابع
          <kbd>+</kbd>
          رو اجرا کنید که دو تا مقدار از
          stack
          بر می‌داره و بعد جوابش رو محاسبه می‌کنه و می‌ذاره تو
          stack
          دوباره.
        </p>
        <pre><code block lang="python">
          + 1 2
          # 3
        </code></pre>

        <p dir="auto">
          با دانشی که توی طول یک هفته بدست اوردم این تابع رو برای محاسبه
          ریشه‌های معادله درجه
          <span digit>2</span>
          نوشتم.

          تابع
          <kbd>⊍</kbd>
          با گرفتن ضرایب
          <latex>a</latex> و
          <latex>b</latex> و
          <latex>c</latex>
          ریشه‌هارو توی یک آرایه دوتایی
          خروجی می‌ده.

          البته حالت بدون ریشه رو تشحیص نمی‌ده
        </p>

        <pre><code block lang="python">
          ² ← ×.    # square

          Δ ← ( # b² - 4(a)(c)
            ⊃(∘|⋅⋅∘|²⋅∘)
            -××4
          )

          ⊍ ← ( # ax² + bx + c = 0  -->  x₁₂ = -b±√Δ/2a, returns [x₁ x₂]
            ⊃(√Δ|¯⋅∘|×2∘) # √Δ -b 2a
            ⊂⊃(+|-)
            ÷:
          )

          ⊍ 1 5 6    # 1x² + 5x + 6
          ## [¯2 ¯3]
        </code></pre>

        <p dir="auto">
          می‌دونم چیز عجیب غریبیه،
          سعی می‌کنم یکم اش رو توضیح بدم،
          برای فهم بقیه باید برید و خودتون یادبگیرید ولی ساده است.

          از تابع توان
          <span digit>2</span>
          یا
          <kbd>²</kbd>
          شروع می‌کنم:
        </p>

        <pre><code block lang="python">
          ² ← ×.
        </code></pre>

        <p dir="auto">
          یادتون باشه که گفتم از راست به چپ باید بخونید.

          اولین عبارت،
          یک نقطه
          <kbd>.</kbd>
          هست،
          یعنی از آخرین چیزی که توی
          stack
          هست ی
          copy
          بگیر.
          تابع
          <kbd>×</kbd>
          هم که یعنی دو تا عدد از
          stack
          بردارد و باهم ضرب کن.

          پس
          <kbd>× . 3</kbd>
          در حقیقت یعنی
          <kbd>× 3 3</kbd>
          که می‌شه
          <span digit>9</span>.
          به همین سادگی تابع مربع یا همون توان
          <span digit>2</span>
          رو تعریف کردیم.

          یعنی از الان با نوشتن
          <kbd>² 6</kbd>
          می‌تونیم توان دوم
          <span digit>6</span>
          رو حساب کنیم که میشه
          <span digit>36</span>
        </p>

        <p dir="auto">
          تابع بعدی تابع محاسبه
          دلتا
          <kbd>Δ</kbd>
          هست که فرمولش اینه:
        </p>
        <latex block>
          \Delta = b^2 - 4ac
        </latex>

        <p dir="auto">
          کدش می‌شه:
        </p>
        <pre><code block lang="python">
          Δ ← (
            ⊃(∘|⋅⋅∘|²⋅∘)
            -××4
          )
        </code></pre>

        <p dir="auto">
          توجه کنید که ورودی به تابع به صورت
          a b c
          داده می‌شه.
          پس
          stack
          تابع
          قبل اجرای چیزی به صورت زیر هست:
        </p>
        <ol>
          <li>
            <latex>a</latex>
          </li>
          <li>
            <latex>b</latex>
          </li>
          <li>
            <latex>c</latex>
          </li>
        </ol>
        <p dir="auto">
          عبارت
          <kbd>⊃(∘|⋅⋅∘|²⋅∘)</kbd>
          ترتیب مقدار ها توی
          stack
          رو تغییر می‌ده.
          <kbd>∘</kbd>
          یعنی اولین چیزی که توی
          stack
          هست.
          عبارت
          <kbd>⋅</kbd>
          یعنی بنداز دور.
          پس
          <kbd>⋅⋅∘</kbd>
          یعنی اولی و دومی رو بنداز دور و سومی رو بچسب.
          <kbd>²⋅∘</kbd>
          هم یعنی که اولی رو بنداز دور و دومی رو به توان
          <span digit>2</span>
          برسون
        </p>
        <p dir="auto">
          خب پس الان چیزایی که توی
          stack
          تابع قرار داره به ترتیب اینا هستن:
        </p>

        <ol>
          <li>
            <latex>a</latex>
          </li>
          <li>
            <latex>c</latex>
          </li>
          <li>
            <latex>b^2</latex>
          </li>
        </ol>

        <p dir="auto">
          میرسیم به
          <kbd>-××4</kbd>
          که یعنی
          اول
          <span digit>4</span>
          رو بنداز توی
          stack.
        </p>

        <ol>
          <li>
            <latex>4</latex>
          </li>
          <li>
            <latex>a</latex>
          </li>
          <li>
            <latex>c</latex>
          </li>
          <li>
            <latex>b^2</latex>
          </li>
        </ol>

        <p dir="auto">
          بعد دوتای بالایی رو ضرب کن:
          <kbd>×</kbd>
        </p>

        <ol>
          <li>
            <latex>4a</latex>
          </li>
          <li>
            <latex>c</latex>
          </li>
          <li>
            <latex>b^2</latex>
          </li>
        </ol>

        <p dir="auto">
          دوباره دوتای بالایی رو ضرب کن:
          <kbd>×</kbd>
        </p>
        <ol>
          <li>
            <latex>4ac</latex>
          </li>
          <li>
            <latex>b^2</latex>
          </li>
        </ol>


        <p dir="auto">
          بعد دوتای بالایی رو از هم کم کن:
          <kbd>-</kbd>
        </p>


        <ol>
          <li>
            <latex>b^2 - 4ac</latex>
          </li>
        </ol>

        <p dir="auto">
          بفرما! جواب شما آماده است!
          🥳
        </p>
      </li>
      <li>
        <b>
          array based
        </b>:
        بالاتر توضیح دادم
      </li>
      <li>
        <b>
          functional
        </b>
        یعنی چیزایی که داری
        قابلیت تغییر جزئی ندارن.
        اگر مثلا آخرین چیز توی
        stack
        ات یک آرایه باشه،
        و بخوای چند تا از خونه هاش رو پاک کنی،
        باید قبلی رو از بین بره و ی جدید ساخته بشه.

        این موضوع به خودی خود بد نیست ولی
        ممکنه توی سرعت تاثیر بدی بزاره
      </li>
    </ul>

    <h4 dir="rtl">
      مزایا
    </h4>

    <ul dir="rtl">
      <li>
        واقعا توضیحات و آموزش خوبی داشت؛
        آخر بعضی از آموزش‌هاش هم تمرین با جواب گذاشته بود.
        البته با دوره
        <span digit>9</span>
        قسمته
        <a href="https://www.youtube.com/watch?v=9T3UU5gbRA8">
          Uiua
          برای مبتدیان
        </a>
        شروع کردم و راه انداخت منو
      </li>
      <li>
        به نظرم
        <b>
          کاراکتر های مناسبی
        </b>
        برای
        هر کدوم از قابلیت‌ها انتخاب شده بود و کاملا منطقی بود
      </li>
      <li>
        <b>
          ساده است
        </b>
        و شاید توی کمتر از یک روز بتونید
        باهاش برنامه بنویسید
      </li>
      <li>
        بر خلاف زبان
        APL
        یا همین
        BQN
        که بعدی هست،
        لازم نیست حتما کاراکتر تابع یا مفهوم مورد نظر رو بنویسید،
        اگر چند حرف از اسمش رو هم بنویسید، خودش می‌فهمه و با
        کاراکترش جایگزین می‌کنه
      </li>
    </ul>

    <h4 dir="rtl">
      معایب
    </h4>

    <ul dir="rtl">
      <li>
        شاید گل سر سبد این زبان‌های
        stack based
        زبان‌های
        Post Script
        و
        Forth
        باشن.

        نظر شخصیم اینه که
        شاید این روش برنامه نویسی توی کارهای کوچیک ساده تر باشه
        ولی هرچی برنامه بزرگتر می‌شه،
        دغدغه شما از حل مسئله دور می‌شه
        و می‌ره به سمت مدیریت ترتیب
        stack
        <small par>
          البته شاید با تمرین و تکرار زیاد
          دیگه بهش فکر نکنی و آسون بشه،
          مثل رانندگی یا هر مهارت دیگه
        </small>
      </li>

      <li>
        چون خیلی تازه معرفی شده،
        <small par>
          سال
          <span digit>2023</span>
        </small>،
        نه
        community
        داره و
        خیلی چیزا بهش اضافه نشده یا پیاده سازیش آسون نیست.
        مثل عبارت شرطی
      </li>
    </ul>

    <h3 dir="rtl">
      BQN
    </h3>

    <figure>
      <img class="pl-logo" src="https://aplwiki.com/images/4/4d/BQN_logo.png" alt="">
    </figure>

    <p dir="auto">
      راستش همه اول
      BQN
      رو یادگرفتن
      و بعد رفتن سراغ
      Uiua.
      اما من دقیقا برعکس این کار رو کردم.
    </p>

    <h4 dir="auto">
      مزایا
    </h4>

    <p dir="auto">
      بخاطر مشکلات
      Uiua
      به این زبان پناه اوردم.
      این زبانی
      functional
      هست
      <span footnote>
        <a href="https://github.com/codereport/array-language-comparisons">
          Array Language & Library Comparisons
        </a>
      </span>
      ولی
      مشکلات
      Uiua
      رو نداره و صد البته پایدار تره
      .
      به نظرم این زبان
      <mark>
        به حدی ساده است که باید توی مدرسه به
        دانش آموز های دبیرستانی درس داد.
      </mark>
      برای نمونه دو تا تکه کد اوردم باهم ببینیم:
    </p>

    <h5 dir="auto">
      محاسبه مقاومت معادل سری
    </h5>

    <p dir="auto">
      اگر چند تا مقاومت توی مدار پشت‌ سر هم یا به اصطلاح
      سری وصل شده باشن،
      فرمول مقاومت معادل از این رابطه بدست میاد:
    </p>

    <latex block>
      R_t = R_1 + R_2 + R_3 + ...
    </latex>

    <p dir="auto">
      کد معادل عبارت بالا می‌شه:
    </p>
    <pre><code block lang="python">
      +´
    </code></pre>
    <p dir="auto">
      به همین راحتی!
      حالا این کد یعنی چی؟
      خب
      <kbd>+</kbd>
      که یعنی همون جمع خودمون
      و
      <kbd>`</kbd>
      هم یعنی که
      تابع پشتش رو بین تک تک اعضا اعمال کن.
    </p>

    <p dir="auto">
      پس یعنی اگر
      ما
      <span digit>3</span>
      مقاومت
      <latex>R_1 = 1</latex> و
      <latex>R_2 = 2</latex> و
      <latex>R_3 = 3</latex>
      داشته باشیم،
      جواب اینطوری نوشته می‌شه
    </p>
    <pre><code block lang="python">
      +´ ⟨1,2,3⟩
    </code></pre>
    <p dir="auto">
      که معادل کد زیر هست
    </p>
    <pre><code block lang="python">
      1 + 2 + 3
    </code></pre>

    <h5 dir="auto">
      محاسبه مقاومت معادل موازی
    </h5>

    <p dir="auto">
      فرمول ریاضی:
    </p>

    <latex block>
      \frac{1}{R_t} = \frac{1}{R_1} + \frac{1}{R_2} + \frac{1}{R_3} + ...
    </latex>

    <p dir="auto">
      کد معادل:
    </p>

    <pre><code block lang="python">
      +´⌾÷
    </code></pre>

    <p dir="auto">
      <i>همین؟</i>
      اره، فقط 4 تا حرف لازم بود. خب حالا بریم ببینیم چطور کار می‌کنه
    </p>

    <p dir="auto">
      اول از همه
      <kbd>⌾</kbd>
      ی عملگر هست که کنارش دوتا تابع قرار می‌گیرن
      و عبارت
      <kbd>G⌾F</kbd>
      در حقیقت یعنی
      <kbd>F⁻¹ G F</kbd>.
      که با جایگذاری داریم:
    </p>

    <pre><code block lang="python">
      ÷⁻¹ +´ ÷
    </code></pre>

    <p dir="rtl">
      اگر تابع
      <kbd>÷</kbd>
      <span digit>2</span>
      تا ورودی داشته باشه، تقسیم رو انجام می‌ده
      ولی اگر فقط
      <span digit>1</span>
      ورودی داشته باشه،
      معکوس می‌کنه.
      یعنی مثلا
      <kbd>÷2</kbd>
      می‌شه
      <kbd>½</kbd>.

      <kbd>+`</kbd>
      هم رو که قسمت قبل یادگرفتیم
      و فقط می‌مونه
      <kbd>÷⁻¹</kbd>،
      این
      <kbd>-1</kbd>
      بالای تابع یعنی معکوس خودش.
    </p>

    <p dir="auto">
      فرض کنید مقاومت‌هامون همونایی هستن که توی قسمت قبل استفاده شدن.
      حالا بهتون نشون می‌دم که چطور اجرا می‌شه:
    </p>

    <pre><code block lang="python">
      ÷⁻¹ +´ ÷ ⟨1, 2,   3⟩
      ÷⁻¹ +´   ⟨1, 0.5, 0.3333⟩
      ÷⁻¹       1.83333
      0.54545454
    </code></pre>

    <h4 dir="auto">
      معایب
    </h4>

    <ul dir="rtl">
      <li>
        اینکه برای تغییر
        یک آرایه باید ازش کپی بگیری،
        یکم از لحاظ حافظه اشغالی توی
        RAM
        و سرعت
        می‌تونه اذیت بکنه.

        البته تا جایی که می‌تونید نباید از این کار ها توی زبان های
        functional
        مثل این بکنید
      </li>

      <li>
        ساختمان داده
        hash map
        نداره و فقط آرایه داره.

        نمی‌دونم چقد نیاز می‌شه ولی به نظرم باید می‌بود چنین چیزی
      </li>
    </ul>


    <h2 dir="auto">
      بررسی
    </h2>

    <ul dir="rtl">
      <li>
        <p dir="auto">
          <b>
            فکر نمی‌کنی وقت تلفی بود این همه
            یادگیری؟ واقعا ارزشش رو داشت؟
          </b>
          نه اصلا!
          هر سال زبان هایی یادگرفتم که
          تفکر و فلسفه متفاوتی نسبت به بقیه داشتن.

          حتی اگر از این زبان‌ها در آینده استفاده نکنم.
        </p>
        <p>
          این نقل‌قول رو خیلی دوست دارم و به‌نظرم درسته:
        </p>
        <blockquote align="left">
          progress is impossible without change,
          and those who cannot change their minds
          <mark>cannot change anything</mark>

          <cite>
            -- Bernard Shaw
          </cite>
        </blockquote>

        <p dir="auto">
          این نکته رو هم باید توجه کنید که
          اگر چیزی رو در نگاه اول متوجه نشید،
          دلیل نمی‌شه اون چیز پیچیده باشه
          <span footnote>
            <a href="https://vector-of-bool.github.io/2018/10/31/become-perl.html">
              foreign ≠ confusing
            </a>
          </span>
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            با دونستن این همه زبون جدید،
            قاطی نمی‌کنی؟
          </b>

          اولا از همه‌شون استفاده نمی‌کنم در حال حاضر،
          ولی نه اتفاقا خودمم تعجب می‌کنم که
          فرق‌هاشون یادم مونده
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            کدومشون بهتر بود؟
            الان خودت از کدوما استفاده می‌کنی؟
          </b>
          راستش من از
          Nim
          خیلی خوشم اومد و از موقعی
          که یادش گرفتم، تقریبا همه جا ازش استفاده می‌کنم،

          از
          BQN
          هم تفننی برای حل مسئله استفاده می‌کنم.

          زبان‌های
          Javascript
          و
          Python
          هم کاربردشون زیاده و بعضی موقع‌ها نیاز می‌شه
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            چطوری تمرین می‌کردی زبون‌هایی که یادگرفتی رو؟
          </b>
          بستگی داره ولی
          حل مسئله های سایت
          <a href="https://adventofcode.com">
            Advent of Code
          </a>
          واسه شروع خوبه چون خیلی به روش‌های
          مختلف حلش کردن و جوابش رو توی اینترنت گذاشتن.
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            باهاشون پروژه زدی؟
          </b>

          اره چندتایی زدم.
          بزرگترین‌شون
          <a href="https://github.com/hamidb80/ReMS">
            سیستم مدیریت یادآوری
          </a>
          بود که
          به دلیل اینکه خیلی کاربردی نبود، از کار انداختمش.
          ولی دمو هاش موجوده
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            به منم پیشنهاد میکنی همین کار رو بکنم؟
          </b>

          راستش من بیشتر از
          <i>
            مهندسی نرم‌افزار
          </i>
          خوشم میاد و زبان‌های مختلف
          برام جذابه؛
          به علاوه فعلا مشکل مالی ندارم و تشکیل زندگی ندادم.

          شاید شما بخواید توی زمینه دیگه‌ای مثل
          هوش مصنوعی یا زیست‌فناوری
          فعالیت کنید و واسه‌تون این موراد مهم نباشه.

          یا اینکه شما مهارتتون کمه و ترجیح می‌دید اول
          جایی کار کنید یا تجربه‌ای کسب کنید و بعد اگر فرصت شد
          دنبالش برید.
        </p>
        <p>
          یاد داستانی افتادم
          که خیلی به این سوال مربوط می‌شه:
        </p>
        <blockquote>
          <p>
            روزی گربه می‌خواست از رود رد بشه، ولی می‌ترسید که عمق آب زیاد باشه و غرق بشه
          </p>

          <p>
            می‌دونست که
            شتر هر روز از اونجا رد می‌شه؛
            بخاطر همین از شتر در مورد عمق آب پرسید
          </p>

          <p>
            شتر در جواب گفت که آب تا زانوی من بالا میاد.
            گربه با خیال راحت دل رو به رود زد و
            همونطور که حدس زدید،
            داشت غرق می‌شد ولی با بدبختی تونست خودشو هرطوری که هست نجات بده.
          </p>

          <p>
            با عصبانی برگشت پیش شتر و بهش گفت:
            <b>
              مگه نگفتی که عمق رود تا زانو هست؟
            </b>
          </p>
          <p>
            شتر گفت:
            <mark>
              من گفتم زانوی خودم نه زانوی تو!
            </mark>
          </p>
        </blockquote>

        <p>
          پس حتما پیشنهاد هارو با
          <i>
            شرایط زندگی خودتون
          </i>
          بسنجید،
          ممکنه بهترین پیشنهاد ها بدرد شما نخورن
        </p>
      </li>

      <li>
        <p dir="auto">
          <b>
            اینا توی بازار کار بدرد نمیخوره.
            چه فایده؟
          </b>

          اگر بازه دید تون تو گسترش بدید
          و کمی در مورد تاریخچه زبان‌های برنامه نویسی مطالعه کنید،
          متوجه می‌شید که خیلی از زبون‌های ی مدت توی بورس بودن و خیلی استفاده می‌شدن،
          الان تقریبا مرده‌اند چون جایگزین‌های خیلی بهتری اومده.
        </p>

        <p>
          نکته دیگه هم اینکه فکر نکن چون تو نمی‌شناسی
          جایی رو که با این‌ها کار کنن، پس بازار کار نداره
        </p>
      </li>

    </ul>

  </article>

  <tags>
    #blog
    #programming
    #uni
    #lang fa
  </tags>
</note>